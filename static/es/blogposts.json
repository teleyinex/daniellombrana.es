{
  "2019-01-25-jekyll2nuxtjs": {
    "layout": "blog",
    "title": "Pasa de Jekyll a NuxtJS sin dolor",
    "date": "2019-01-18T00:00:00.000Z",
    "quote": "Lorem ipsum dolor sit amet, consectetur adipisicing elit",
    "icon": "moving",
    "icon_author": "Ethan Weil",
    "icon_url": "https://unsplash.com/photos/9Q7PqDxCZeQ?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText",
    "description": "Aprende cómo convertir tu sitio Jekyll en uno con NuxtJS",
    "author": "teleyinex",
    "preview": "Últimamente todo el mundo habla de crear sitios estáticos para la …",
    "content": "\n\nÚltimamente todo el mundo habla de crear sitios estáticos para la web. Normal, no necesitas un servidor y además hay varios sitios en la web que nos permiten hospedarla sin coste alguno (Netlify, Github Pages, Zeit now, ...).\n\nAhora mismo hay más de [200 frameworks](https://www.staticgen.com/). Puedes encontrar, casi seguro, el que se adapte a tus necesidades, porque hay prácticamente  uno para cada lenguaje de programación.\n\nUno de los más populares es [Jekyll](https://www.staticgen.com/jekyll). Atesora más de 36 mil estrellas en Github, seguido muy de cerca por [Next](https://www.staticgen.com/next) y [Hugo](https://www.staticgen.com/hugo).\n\nComo te puedes imaginar, llevo usando Jekyll bastante tiempo. De hecho, todas mis webs están hechas con Jekyll: [Scifabric.com](https://scifabric.com), [PYBOSSA](https://pybossa.com) y hasta ahora mi sitio web (donde estás ahora mismo).\n\nLa simplicidad de Jekyll es increíble. Puedes empezar a programar y montar una web en minutos. Además, si sabes bastante de JS, o si quieres crear una \"Progressive Web Application\", Jekyll no es la mejor opción. Y por ese motivo decidí buscar alternativas.\n\nPor tanto, ¿qué podía hacer? Bueno, la historia es que comencé a programar con VueJS desde su versión 1.0, luego la 2.0 y finalmente encontré [NuxtJS](https://nuxtjs.org/) y fue amor a primera vista :heart_eyes:.\n\nNuxtJS es una pasada por varios motivos:\n\n* **Rendimiento**: utiliza todas las buenas prácticas de VueJS y NodeJS, asegurando generar el código más limpio y pequeño para tu web.\n* **Modular**: tienes para elegir entre más de 50 módulos que te ahorrarán un montón de trabajo. Puedes construir una PWA sin tener que escribir una sóla línea de código.\n* **Divertido**: esta es probablemente una de sus mejores características. A mi no me entusiasmaba programar en JS hasta que descubrí VueJS y posteriormente NuxtJS.\n\nEste amor ha surgido al trabajar todo el rato con NuxtJS en Scifabric. En la actualidad lo usamos para todos los clientes, dado que podemos crear sitios web muy rápidamente y además ofrecer PWA sin problema alguno. Un ejemplo, por si quieres echar un ojo, es el proyecto que hicimos para Greenpeace España: [https://solarmaps.greenpeace.org](https://solarmaps.greenpeace.org).\n\nAl trabajar más y más con NuxtJS llegó un punto en el que empecé a preguntarme si sería muy difícil migrar mi página web de Jekyll a NuxtJS. ¿Por qué te preguntaras? Pues porque me he acostumbrado (malamente, tra, tra) a Axios, Componentes, Stylus, ... y no quiero dejarlo :smiley:\n\nEl único problema es que mi sitio web tiene varias carpetas con contenido en Markdown y que además uso el front-matter para renderizarlo de una u otra forma dependiendo de en qué URL esté. El caso es que me lié la manta a la cabeza y comencé a investigar y ver si era posible, y obviamente lo es :smiley_cat:\n\n\n## Manejando Markdown en NuxtJS\n\nComo de costumbre, la comunidad open source es maravillosa. Había varias herramientas que me permitían importar y trabajar directamente con ficheros Markdown. Por ejemplo, puedes utilizar el [cargador de ficheros Markdown para Webpack](https://www.npmjs.com/package/frontmatter-markdown-loader).\n\nEste cargador fue mi primer intento. Sin embargo, mientras que en modo desarrollo iba bien, en cuanto construía el sitio estático fallaba. La consola web se quejaba de que el cargador no estaba disponible, y daba un error que no me dejaba ver mis proyectos, blogs, etc. \n\nEntonces se me ocurrió una idea :bulb:. ¿Y si lo intentaba hacer todo más sencillo? ¿Y si transformaba los ficheros Markdown directamente a JSON? Hice una rápida busca en San Google y encontré justo lo que buscaba:  [markdown-to-json](https://www.npmjs.com/package/markdown-to-json).\n\nEsta librería es PERFECTA. ¿Por qué? Porque puedes pasarle una carpeta con ficheros Markdown, los leerá y los transformará en un objecto JSON. Así tienes en un solo fichero todos tus blog posts, proyectos, etc. Además el front-matter se parsea, y te queda dentro del JSON, con lo que un problema menos. Gracias a que ahora todos mis datos están en formato JSON, puedo solicitarlos vía HTTP (gracias Axios).\n\nMi primera prueba fue con el blog y todo funcionó a la primera. Así que era hora de automatizarlo todo: creé una carpeta llamanda **content** en la que guardaré todos mis blog posts, proyectos, etc. Luego tan solo tengo que ejecutar un comando como el siguiente:\n\n```\n$ m2j -c content/blogposts/*.md -o static/blogposts.json\n```\nDe esta forma, me quedan todos los artículo de mi blog en un fichero JSON en la carpeta /static de NuxtJS. Estos ficheros se sirven directamente por el servidor web, por lo que puedo solicitarlos vía Axios. Con esto ya tengo todo lo que necesito. Lo único restante es decirle a NuxtJS cómo generar todas las rutas para esos artículos (en modo SSR no haría falta, pero al hacer una web estática, sí que hace falta, jeje).\n\n## Creando rutas en NuxtJS\n\nPara crear las rutas solo tenemos que modificar el fichero package.json con un par de comandos más:\n\n```\n    \"dev\": \"yarn md2json && nuxt\",\n    \"build\": \"yarn md2json && nuxt build\",\n    \"md2json\": \"m2j -c content/blogposts/*.md -o static/blogposts.json\"\n\n```\nGracias a esta solución, cuando ejecutas *yarn dev* (o npm run dev) tus artículos del blog se convierten a JSON y el servidor de desarrollo lo tendrá todo listo para que te pongas manos a la obra. Por cierto, hacemos lo mismo para generar el sitio estático con yarn run build y así podremos desplegar nuestro sitio web en Zeit, Github Pages o Netlify.\n\nCon esto resuelto, tan solo quedaba migrar mis estilos, plantillas y demás. Esto fue más o menos sencillo porque ya estaba usando webpack para montar todo el sitio en Jekyll. Así que en muchos casos sólo tuve que copiar y pegar trozos de código y adaptarlos a NuxtJS.\n\n¿El resultado? Esta página. Ahora mismo es increíblemente rápida. Si además estás leyendo esto desde un móvil Android (o iOS última versión) el navegador web (si es Chrome) te preguntará si quieres instalar mi sitio web en tu móvil.  \n\nY lo que es mejor, mirad la puntuación en Google:\n\n![Auditoría del sitio por Google](/assets/img/blog/audits-daniel.png)\n\n## Una plantilla\n\nMientras realizaba la migración de mi sitio web me di cuenta de que esto podría servirle a más gente, así que he creado una plantilla muy básica que puedes re-utilizar. El código está disponible aquí: [https://github.com/teleyinex/jekyll2nuxt](https://github.com/teleyinex/jekyll2nuxt).\n\nEsta plantilla utiliza [VuetifyJS](http://vuetifyjs.com/), así que tendrás el look Material de Google para tu sitio web. Además está configurado con PWA y los módulos de Markdown que he descrito en este artículo, así que está todo listo para utilizarse. Tan solo tienes que copiar tus ficheros Markdown a la carpeta **content** y ejecutar **yarn dev**.\n\nSi has leído hasta aquí, MIL GRACIAS por tu tiempo :raised_hands:. Me ayudaría un montón si compartes este artículo por Twitter (o Facebook) con tu gente, para que más gente lo conozca.\n",
    "iso8601Date": "2019-01-18T01:00:00+01:00",
    "basename": "2019-01-25-jekyll2nuxtjs"
  },
  "2019-01-25-lambdawebscrapping": {
    "layout": "blog",
    "title": "Una API para la calidad del aire de Madrid con menos de 50 líneas de código",
    "date": "2019-01-18T00:00:00.000Z",
    "quote": "Lorem ipsum dolor sit amet, consectetur adipisicing elit",
    "icon": "pollution",
    "icon_author": "Thomas Millot",
    "icon_url": "https://unsplash.com/photos/q5jKHtV4hWc",
    "description": "Usando funciones lambda para crear APIs",
    "author": "teleyinex",
    "preview": "# Funciones Lambda\n\nLas funciones …",
    "content": "\n\n# Funciones Lambda\n\nLas funciones [lambda](https://en.wikipedia.org/wiki/AWS_Lambda) llevan con nosotros desde 2014, más o menos. El caso es que\naunque entendía cómo funcionaban no les veía un uso práctico. Hasta este fin de\nsemana :stuck_out_tongue_winking_eye:.\n\nPor si es la primera vez que oyes este término, una función lambda es un\nservicio web, puede ser Amazon, Zeit o Netlify, que te permiten ejecutar una\nfunción (en tu lenguaje de programación favorito) cuando accedes a una URL\nespecífica.\n\nLas ventajas sobre el papel es que no hay un servidor funcionando todo el rato,\npor lo que te cobran solo por cada una de las llamadas a dicha URL y por lo\ntanto \"debería ser más barato\".\n\nClaro, al ser serverless, pues eso, no tienes acceso a bases de datos, y por lo\ntanto no \"puedes hacer muchas cosas\". De ahí que no le viese la utilidad\ndirectamente. Hasta que se me encendió la bombilla.\n\n## Creando APIs con funciones Lambda\n\nPor mi trabajo, curro mucho con datos. Generalmente trabajo con datos abiertos,\nes decir, que están disponibles públicamente, pero generalmente estos datos no\ntienen una API asociada.\n\nNormalmente en estos casos lo que hacen es darte un fichero XML, CSV o similar\nque tienes que descargar todos los días o cada equis horas para poder trabajar\ncon ellos. Vamos, un lío.\n\nEl caso es que vale, eso funciona, pero no es lo mejor. Sobretodo si quieres\nhacer búsquedas, porque en ese caso tendrás que hacerte tú la búsqueda o\nalmacenar todos los datos en tu base de datos favorita.\n\nTodo esto claro depende de cómo quieres que sea tu proyecto. Si lo único que\nquieres es mostrar datos antiguos, o agregados, el CSV o XML es perfecto, pero\nsi lo que quieres es hacer algo más dinámico, pues ya tienes que andar enredando\nun poco con el código :smile:\n\nDe esta necesidad salió mi respuesta a las funciones lambda: ¿y si pudiésemos\nusar una función para hacer scrapping de una web con datos abiertos y devolver todo en formato JSON\nbonico? Pues efectivamente se puede y funciona a las mil maravillas.\n\n## Una API para la calidad del Aire de Madrid\n\nTodo esto se me ocurrió porque hace un tiempo estuve intentando ver cómo se\npublicaban los datos de la calidad del aire en Madrid. El resultado es un poco\ntriste, puesto que tienes los CSV y XML que he dicho y una predicción por horas\no un boletín en formato PDF. Vamos, un lío si quieres hacer algo chulo, como por\nejemplo una Progressive Web Application.\n\n![pantallazo de la web del Ayuntamiento](/assets/img/blog/aire1.png)\n\nLa web del Ayuntamiento te muestra los datos. Pero claro, no es responsive,\ntiene 5 tablas (una dentro de otra) para hacer el layout... :scream: (alguien\ndebería hablarles de HTML5, flexbox y grid).\n\nAsí que me puse manos a la obra. Tras cacharrear un rato con la web del\nAyuntamiento, descubrí que en la predicción por horas, puedes\nseleccionar una estación, así como una fecha y/o contaminante. Tras abrir las dev tools de\nChrome, vi que era un formulario y que enviaba algo tal que así:\n\n![pantallazo del formulario](/assets/img/blog/form.png)\n\nPor lo que lo tenía hecho. Tan solo tenía que hacer la misma petición pasándole\nesos datos en el formulario. La página me devolvería un HTML con el que podría\ntrabajar. Y esto está chupado si usas algo como NuxtJS + Axios + Vuetify y creas\nuna PWA en unos minutos :smile_cat:\n\n\n### Funciones lambda en Zeit\n\nCasi siempre trabajo con Python y con JS por lo que Zeit era una buena opción\npara probar lo que quería hacer. Zeit te permite crear funciones lambda para\nambos lenguajes de programación así que perfecto.\n\nEn mi caso, escogí Python y BeautifulSoup4 para hacer el parseo del HTML que me\ndevuelve la página web del Ayuntamiento de Madrid.\n\nLa página web con el resultado tiene muchas tablas (ningún div, madre del amor\nhermoso), así que busqué la que me interesaba. Con la tabla identificado,\nbuscaba los contaminantes (puesto que cada estación tiene los suyos) y genero un\nJSON así de bonito:\n\n```\n{\n\"Dióxido de Azufre[µg/m³]\": [], // 24 items\n\"Dióxido de Nitrógeno[µg/m³]\": [], // 24 items\n\"Ozono[µg/m³]\": [\n22,\n32,\n36,\n41,\n52,\n50,\n46,\n46,\n44,\n-1,\n51,\n54,\n55,\n57,\n59,\n60,\n55,\n52,\n47,\n40,\n41,\n43,\n39,\n39\n],\n\"Hora\": [], // 24 items\n\"estacion\": \"Estación de Villaverde\",\n\"fecha\": \"10/02/2019\"\n}\n```\n\nListo para ser consumido por cualquier librería de JS que pinte unos gráficos\nbonitos. La API me permite por lo tanto pedir los datos de contaminación para\ncualquiera de las estaciones de Madrid en cualquier fecha.\n\nCon esto listo, tan solo tenía que adaptar mi script a la función lambda de\nZeit.\n\nZeit tiene una documentación un [pelín escasa](https://zeit.co/examples/python) con respecto a esto, pero haciendo\nun poco de Google sacas todo lo que necesitas. Con tan solo 47 líneas de código\ntengo una función lambda que parsea la calidad del aire en Madrid en tiempo\nreal :sunglasses::\n\n```\nfrom http.server import BaseHTTPRequestHandler\nimport requests\nimport json\nfrom bs4 import BeautifulSoup\nfrom urllib.parse import urlparse, parse_qs\n\n\nclass handler(BaseHTTPRequestHandler):\n\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.end_headers()\n        estacion = parse_qs(urlparse(self.path).query).get('estacion')[0]\n        date = parse_qs(urlparse(self.path).query).get('date')[0]\n        data = {'menu':  'consulta', 'smenu': 'reports', 'link': 'data',\n                'view': 'data', 'magnitud': '', 'estacion': int(estacion),\n                'date': date}\n        url = 'http://www.mambiente.munimadrid.es/sica/scripts/index.php?lang=es'\n        r = requests.post(url, data=data)\n        soup = BeautifulSoup(r.content, 'html.parser')\n        tables = soup.find_all('table')\n        table = tables[4]\n        meta = table.find_all(class_='hs')\n        headers = table.find_all(class_='hd')\n        tmp = dict()\n        data = table.find_all(class_='datos')\n        val = []\n        for i in range(len(headers)):\n            val.append(list())\n        for idx, d in enumerate(data):\n            k = idx % len(headers)\n            v = d.get_text()\n            if ((':' not in v) and ('-' not in v)):\n                v = float(v)\n            else:\n                if ('-' in v):\n                    v = -1.0\n            val[k].append(v)\n        for idx, h in enumerate(headers):\n            k = idx % len(headers)\n            v = h.get_text()\n            tmp[v] = val[k]\n        tmp['estacion'] = meta[0].get_text()\n        tmp['fecha'] = meta[1].get_text()\n        self.wfile.write(str(json.dumps(tmp)).encode())\n```\n\nFácil sencillo y muy limpio. Lo mejor de todo es que puedes poner la cabecera\nque quieras, por lo que puedes (y debes) habilitar CORS para que tu servidor\nfrontend pueda usarlo.\n\nUna vez hecho, tan solo hay que desplegarlo con el comando: now y ¡listo!\n\n## Progressive Web Application\n\nAquí ahora ya sólo quedaba montar el servidor front. Así que cogí: NuxtJS y creé\nuna página web estática que desplegaría también en Zeit. Es una SPA con PWA\nactivado para que vaya rápido como el rayo. \n\nPara la parte gráfica tiramos de Vuetify y sus Sparklines que nos permiten hacer\nanimaciones super chulas como esta:\n\n<video width=\"100%\" controls>\n  <source src=\"/vid/aire.mp4\" type=\"video/mp4\">\n  Your browser does not support HTML5 video.\n</video>\n\nSi quieres probar la web, aquí tienes el enlace\n[https://aire.daniellombrana.es](https://aire.daniellombrana.es)\n\n## Conclusiones\n\nEstoy muy sorprendido por lo bien que ha ido todo, teniendo en cuenta que he\ndesarrollado esto en unas 4 horas (no había probado antes las funciones lambda).\n\nMe quedo con la idea de que para hacer prototipados rápidos es la caña y puedes\nhacer cosas muy chulas que de otra forma no sería posible.\n\n¿Qué os ha parecido a vosotros? Preguntadme o responderme por Twitter.\n",
    "iso8601Date": "2019-01-18T01:00:00+01:00",
    "basename": "2019-01-25-lambdawebscrapping"
  },
  "2019-02-20-fulltextsearchclient": {
    "layout": "blog",
    "title": "Crea un motor de búsqueda para tu página web estática",
    "date": "2019-01-18T00:00:00.000Z",
    "quote": "Lorem ipsum dolor sit amet, consectetur adipisicing elit",
    "icon": "searching",
    "icon_author": "Forest simon",
    "icon_url": "https://unsplash.com/photos/-TX0ufDSCV4",
    "description": "Cómo crear un motor de búsqueda para tu página web sin servidores",
    "author": "teleyinex",
    "preview": "# Búscando en tu sitio web\n\nLas páginas web estáticas cada vez son …",
    "content": "\n\n# Búscando en tu sitio web\n\nLas páginas web estáticas cada vez son más populares, sin embargo tienen un\nproblemilla: no puedes indexar a priori todos tus datos y hacerlos accesibles en\nla web.\n\n\n<div style=\"width:100%;height:0;padding-bottom:73%;position:relative;\"><iframe src=\"https://giphy.com/embed/l3q2PZSVUUEsajBIY\" width=\"100%\" height=\"100%\" style=\"position:absolute\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe></div><p><a href=\"https://giphy.com/gifs/oscars-academy-awards-1952-l3q2PZSVUUEsajBIY\">via GIPHY</a></p>\n\nExisten servicios como Angolia, o servidores web como Solr. El primero es más o\nmenos sencillo, pero al final tienes que tener tu web indexada por un tercero.\nLa opción de Solr es muy chula, pero claro, si tienes tu web en un servidor\nestático tipo Github Pages, pues como que no puedes usarlo :smile:. Así que,\n¿qué solución te queda?\n\n## Lunr.JS, parecido a Solr, más pequeño y con mucho menos brillo\n\n<div style=\"width:100%;height:0;padding-bottom:100%;position:relative;\"><iframe src=\"https://giphy.com/embed/rZKXaQyfvZQv6\" width=\"100%\" height=\"100%\" style=\"position:absolute\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe></div><p><a href=\"https://giphy.com/gifs/moon-cute-black-rZKXaQyfvZQv6\">via GIPHY</a></p>\n\nEn mi afán por buscar una solución a este problema, me econtré con esta\nlibrería: [LunrJS](https://lunrjs.com/)\n\nLa librería es muy pequeña, se puede instalar con yarn (o si lo prefieres con\nnpm). Te permite indexar cientos de documentos sin problemas, tan solo tienes\nque especificar qué campos quieres indexar y cual de ellos vas a utilizar como\nreferencia (un identificador único).\n\nSi además te digo que hace stemming, y que soporta varios idiomas, pues la\nverdad es que pensarás que es la leche :wink:.\n\nNOTA: el stemming es una función de búsqueda que hace que se encuentre un\ndocumento conjugando un verbo, que sean palabras indistintamente en plural o\nsingular, etc.\n\n### Integrando Lunrjs en Nuxtjs\n\n<div style=\"width:100%;height:0;padding-bottom:42%;position:relative;\"><iframe src=\"https://giphy.com/embed/AvMJCeu1EMmhG\" width=\"100%\" height=\"100%\" style=\"position:absolute\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe></div><p><a href=\"https://giphy.com/gifs/reaction-this-is-the-end-breaks-AvMJCeu1EMmhG\">via GIPHY</a></p>\n\nPara integrarlo no hay mucha complicación. Tan solo lo importamos tal que así:\n\n```\nvar lunr = require(\"lunr\")\nrequire('lunr-languages/lunr.stemmer.support')(lunr)\nrequire('lunr-languages/lunr.multi')(lunr)\nrequire('lunr-languages/lunr.es')(lunr)\n```\n\nY luego nos vamos a nuestra función asyncData o created (dependendiendo de dónde\nconsigas los datos a indexar) y haces algo tal que así:\n\n```\n  created() {\n    const self = this\n    const idx = lunr(function() {\n      this.use(lunr.multiLanguage('en', 'es'))\n      this.ref('basename')\n      this.field('content')\n      self.blogposts.forEach(blog => this.add(blog), this)\n    })\n    this.$store.commit('setIdx', idx)\n  },\n```\n\nCon esto le decimos a Lunr cual es el identificador único, en este caso\nbasename. Luego qué campo queremos indexar, en este caso content (que es el\nMarkdown compilado de todos mis blog posts). Finalmente, le pasamos todos los\nblogposts al índice y lo ponemos en la store para que pueda utilizarse desde\ncualquier componente. ¿Sencillo?\n\n### Buscando\n\nAhora ya sólo queda realizar una búsqueda, para eso un método como este sirve:\n\n```\nsearch() {\n  const found = this.$store.state.idx.search(this.query)\n  this.$store.commit('setFound', found)\n}\n```\n\nCon este método, obtenemos los resultados y los colocamos en la store. \n\nNOTA: si quieres hacer un autocompletado, puedes. Lo único es que no quieres\nabusar de la búsqueda, así que usa\n[debounce](https://lodash.com/docs/4.17.11#debounce) de Lodash y descarga un poco de\nllamadas a tu función. \n\n## Resultado\n\nPues el resultado es esta misma web, en la sección del blog. Aquí puedes buscar\ndentro de todos los blog posts escribiendo. A medida que vas escribiendo, el\nmétodo search se llama (a través de debounce) y se actualizan los resultados en\ntiempo real. La búsqueda es muuuuy rápida porque está todo en memoria.\n\nMe encanta porque es una solución, limpia, rápida y sencilla.\n",
    "iso8601Date": "2019-01-18T01:00:00+01:00",
    "basename": "2019-02-20-fulltextsearchclient"
  }
}
